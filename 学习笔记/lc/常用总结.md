### 

### 自定义排序

#### C++

```cpp
// 方法1：Lambda表达式  
vector<vector<int>> arrs;
//[]表示需要作用域的哪些参数传入，这里为空，表示不需要传入任何参数，常见的有=和&
sort(arrs.begin(),arrs.end(),[](const vector<int> &A,const vector<int> & B){
    return A[1] - B[1]; // 根据arrs[i][1] 降序排序
});

// 方法2：函数方法
typedef struct
{
	int x;
	int y;
} point;
//从小到大排序，以x为主序，y为次序
bool cmp(point &a, point &b)
{
	if (a.x == b.x)
	{
		return a.y < b.y;
	}
	return a.x < b.x;
}

point p[10];
sort(p, p + 10, cmp);
```

#### Go

```GO
//1. 排序整数、浮点数和字符串切片
/*
对于 []int, []float, []string 这种元素类型是基础类型的切片使用 sort 包提供的下面几个函数进行排序。

sort.Ints
sort.Floats
sort.Strings
*/
s := []int{4, 2, 3, 1}
sort.Ints(s)
fmt.Println(s) // 输出[1 2 3 4]


//2. 自定义比较器排序
a := []int{5, 3, 4, 7, 8, 9}
sort.Slice(a, func(i, j int) bool {
    return a[i] < a[j]
})
/*
使用 sort.Slice 函数排序,使用一个用户提供的函数来对序列进行排序，函数类型为 func(i, j int) bool,i, j 是序列中的索引
*/
family := []struct {
    Name string
    Age  int
}{
    {"Alice", 23},
    {"David", 2},
    {"Eve", 2},
    {"Bob", 25},
}
 //下面实现排序order by age asc, name desc，如果 age 和 name 都相等则保持原始排序
sort.SliceStable(family, func(i, j int) bool {
    if family[i].Age != family[j].Age {
        return family[i].Age < family[j].Age
    }
    return strings.Compare(family[i].Name, family[j].Name) == 1
})



```

### java

```java
int [][] arr = new int[4][3];
Arrays.sort(boxTypes,(a,b)-> (b[1] - a[1]));

Arrays.sort(arrs, new Comparator<int[]>() {
    @Override
    public int compare(int[] o1, int[] o2) {
        return o1[0] - o2[0];
    }
});
```

